"use strict";

var _HTTPResponse = _interopRequireDefault(require("./HTTPResponse"));
var _querystring = _interopRequireDefault(require("querystring"));
var _logger = _interopRequireDefault(require("../logger"));
var _followRedirects = require("follow-redirects");
var _url = require("url");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const clients = {
  'http:': _followRedirects.http,
  'https:': _followRedirects.https
};
function makeCallback(resolve, reject) {
  return function (response) {
    const chunks = [];
    response.on('data', chunk => {
      chunks.push(chunk);
    });
    response.on('end', () => {
      const body = Buffer.concat(chunks);
      const httpResponse = new _HTTPResponse.default(response, body);

      // Consider <200 && >= 400 as errors
      if (httpResponse.status < 200 || httpResponse.status >= 400) {
        return reject(httpResponse);
      } else {
        return resolve(httpResponse);
      }
    });
    response.on('error', reject);
  };
}
const encodeBody = function ({
  body,
  headers = {}
}) {
  if (typeof body !== 'object') {
    return {
      body,
      headers
    };
  }
  var contentTypeKeys = Object.keys(headers).filter(key => {
    return key.match(/content-type/i) != null;
  });
  if (contentTypeKeys.length == 0) {
    // no content type
    //  As per https://parse.com/docs/cloudcode/guide#cloud-code-advanced-sending-a-post-request the default encoding is supposedly x-www-form-urlencoded

    body = _querystring.default.stringify(body);
    headers['Content-Type'] = 'application/x-www-form-urlencoded';
  } else {
    /* istanbul ignore next */
    if (contentTypeKeys.length > 1) {
      _logger.default.error('Parse.Cloud.httpRequest', 'multiple content-type headers are set.');
    }
    // There maybe many, we'll just take the 1st one
    var contentType = contentTypeKeys[0];
    if (headers[contentType].match(/application\/json/i)) {
      body = JSON.stringify(body);
    } else if (headers[contentType].match(/application\/x-www-form-urlencoded/i)) {
      body = _querystring.default.stringify(body);
    }
  }
  return {
    body,
    headers
  };
};

/**
 * Makes an HTTP Request.
 *
 * **Available in Cloud Code only.**
 *
 * By default, Parse.Cloud.httpRequest does not follow redirects caused by HTTP 3xx response codes. You can use the followRedirects option in the {@link Parse.Cloud.HTTPOptions} object to change this behavior.
 *
 * Sample request:
 * ```
 * Parse.Cloud.httpRequest({
 *   url: 'http://www.parse.com/'
 * }).then(function(httpResponse) {
 *   // success
 *   console.log(httpResponse.text);
 * },function(httpResponse) {
 *   // error
 *   console.error('Request failed with response code ' + httpResponse.status);
 * });
 * ```
 *
 * @method httpRequest
 * @name Parse.Cloud.httpRequest
 * @param {Parse.Cloud.HTTPOptions} options The Parse.Cloud.HTTPOptions object that makes the request.
 * @return {Promise<Parse.Cloud.HTTPResponse>} A promise that will be resolved with a {@link Parse.Cloud.HTTPResponse} object when the request completes.
 */
module.exports = function httpRequest(options) {
  let url;
  try {
    url = (0, _url.parse)(options.url);
  } catch (e) {
    return Promise.reject(e);
  }
  options = Object.assign(options, encodeBody(options));
  // support params options
  if (typeof options.params === 'object') {
    options.qs = options.params;
  } else if (typeof options.params === 'string') {
    options.qs = _querystring.default.parse(options.params);
  }
  const client = clients[url.protocol];
  if (!client) {
    return Promise.reject(`Unsupported protocol ${url.protocol}`);
  }
  const requestOptions = {
    method: options.method,
    port: Number(url.port),
    path: url.pathname,
    hostname: url.hostname,
    headers: options.headers,
    encoding: null,
    followRedirects: options.followRedirects === true
  };
  if (requestOptions.headers) {
    Object.keys(requestOptions.headers).forEach(key => {
      if (typeof requestOptions.headers[key] === 'undefined') {
        delete requestOptions.headers[key];
      }
    });
  }
  if (url.search) {
    options.qs = Object.assign({}, options.qs, _querystring.default.parse(url.query));
  }
  if (url.auth) {
    requestOptions.auth = url.auth;
  }
  if (options.qs) {
    requestOptions.path += `?${_querystring.default.stringify(options.qs)}`;
  }
  if (options.agent) {
    requestOptions.agent = options.agent;
  }
  return new Promise((resolve, reject) => {
    const req = client.request(requestOptions, makeCallback(resolve, reject, options));
    if (options.body) {
      req.write(options.body);
    }
    req.on('error', error => {
      reject(error);
    });
    req.end();
  });
};

/**
 * @typedef Parse.Cloud.HTTPOptions
 * @property {String|Object} body The body of the request. If it is a JSON object, then the Content-Type set in the headers must be application/x-www-form-urlencoded or application/json. You can also set this to a {@link Buffer} object to send raw bytes. If you use a Buffer, you should also set the Content-Type header explicitly to describe what these bytes represent.
 * @property {function} error The function that is called when the request fails. It will be passed a Parse.Cloud.HTTPResponse object.
 * @property {Boolean} followRedirects Whether to follow redirects caused by HTTP 3xx responses. Defaults to false.
 * @property {Object} headers The headers for the request.
 * @property {String} method The method of the request. GET, POST, PUT, DELETE, HEAD, and OPTIONS are supported. Will default to GET if not specified.
 * @property {String|Object} params The query portion of the url. You can pass a JSON object of key value pairs like params: {q : 'Sean Plott'} or a raw string like params:q=Sean Plott.
 * @property {function} success The function that is called when the request successfully completes. It will be passed a Parse.Cloud.HTTPResponse object.
 * @property {string} url The url to send the request to.
 */

module.exports.encodeBody = encodeBody;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfSFRUUFJlc3BvbnNlIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfcXVlcnlzdHJpbmciLCJfbG9nZ2VyIiwiX2ZvbGxvd1JlZGlyZWN0cyIsIl91cmwiLCJvYmoiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsImNsaWVudHMiLCJodHRwIiwiaHR0cHMiLCJtYWtlQ2FsbGJhY2siLCJyZXNvbHZlIiwicmVqZWN0IiwicmVzcG9uc2UiLCJjaHVua3MiLCJvbiIsImNodW5rIiwicHVzaCIsImJvZHkiLCJCdWZmZXIiLCJjb25jYXQiLCJodHRwUmVzcG9uc2UiLCJIVFRQUmVzcG9uc2UiLCJzdGF0dXMiLCJlbmNvZGVCb2R5IiwiaGVhZGVycyIsImNvbnRlbnRUeXBlS2V5cyIsIk9iamVjdCIsImtleXMiLCJmaWx0ZXIiLCJrZXkiLCJtYXRjaCIsImxlbmd0aCIsInF1ZXJ5c3RyaW5nIiwic3RyaW5naWZ5IiwibG9nIiwiZXJyb3IiLCJjb250ZW50VHlwZSIsIkpTT04iLCJtb2R1bGUiLCJleHBvcnRzIiwiaHR0cFJlcXVlc3QiLCJvcHRpb25zIiwidXJsIiwicGFyc2UiLCJlIiwiUHJvbWlzZSIsImFzc2lnbiIsInBhcmFtcyIsInFzIiwiY2xpZW50IiwicHJvdG9jb2wiLCJyZXF1ZXN0T3B0aW9ucyIsIm1ldGhvZCIsInBvcnQiLCJOdW1iZXIiLCJwYXRoIiwicGF0aG5hbWUiLCJob3N0bmFtZSIsImVuY29kaW5nIiwiZm9sbG93UmVkaXJlY3RzIiwiZm9yRWFjaCIsInNlYXJjaCIsInF1ZXJ5IiwiYXV0aCIsImFnZW50IiwicmVxIiwicmVxdWVzdCIsIndyaXRlIiwiZW5kIl0sInNvdXJjZXMiOlsiLi4vLi4vc3JjL2Nsb3VkLWNvZGUvaHR0cFJlcXVlc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEhUVFBSZXNwb25zZSBmcm9tICcuL0hUVFBSZXNwb25zZSc7XG5pbXBvcnQgcXVlcnlzdHJpbmcgZnJvbSAncXVlcnlzdHJpbmcnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgaHR0cCwgaHR0cHMgfSBmcm9tICdmb2xsb3ctcmVkaXJlY3RzJztcbmltcG9ydCB7IHBhcnNlIH0gZnJvbSAndXJsJztcblxuY29uc3QgY2xpZW50cyA9IHtcbiAgJ2h0dHA6JzogaHR0cCxcbiAgJ2h0dHBzOic6IGh0dHBzLFxufTtcblxuZnVuY3Rpb24gbWFrZUNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgcmVzcG9uc2Uub24oJ2RhdGEnLCBjaHVuayA9PiB7XG4gICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgfSk7XG4gICAgcmVzcG9uc2Uub24oJ2VuZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBCdWZmZXIuY29uY2F0KGNodW5rcyk7XG4gICAgICBjb25zdCBodHRwUmVzcG9uc2UgPSBuZXcgSFRUUFJlc3BvbnNlKHJlc3BvbnNlLCBib2R5KTtcblxuICAgICAgLy8gQ29uc2lkZXIgPDIwMCAmJiA+PSA0MDAgYXMgZXJyb3JzXG4gICAgICBpZiAoaHR0cFJlc3BvbnNlLnN0YXR1cyA8IDIwMCB8fCBodHRwUmVzcG9uc2Uuc3RhdHVzID49IDQwMCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGh0dHBSZXNwb25zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShodHRwUmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3BvbnNlLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gIH07XG59XG5cbmNvbnN0IGVuY29kZUJvZHkgPSBmdW5jdGlvbiAoeyBib2R5LCBoZWFkZXJzID0ge30gfSkge1xuICBpZiAodHlwZW9mIGJvZHkgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHsgYm9keSwgaGVhZGVycyB9O1xuICB9XG4gIHZhciBjb250ZW50VHlwZUtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKS5maWx0ZXIoa2V5ID0+IHtcbiAgICByZXR1cm4ga2V5Lm1hdGNoKC9jb250ZW50LXR5cGUvaSkgIT0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGNvbnRlbnRUeXBlS2V5cy5sZW5ndGggPT0gMCkge1xuICAgIC8vIG5vIGNvbnRlbnQgdHlwZVxuICAgIC8vICBBcyBwZXIgaHR0cHM6Ly9wYXJzZS5jb20vZG9jcy9jbG91ZGNvZGUvZ3VpZGUjY2xvdWQtY29kZS1hZHZhbmNlZC1zZW5kaW5nLWEtcG9zdC1yZXF1ZXN0IHRoZSBkZWZhdWx0IGVuY29kaW5nIGlzIHN1cHBvc2VkbHkgeC13d3ctZm9ybS11cmxlbmNvZGVkXG5cbiAgICBib2R5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KGJvZHkpO1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoY29udGVudFR5cGVLZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGxvZy5lcnJvcignUGFyc2UuQ2xvdWQuaHR0cFJlcXVlc3QnLCAnbXVsdGlwbGUgY29udGVudC10eXBlIGhlYWRlcnMgYXJlIHNldC4nKTtcbiAgICB9XG4gICAgLy8gVGhlcmUgbWF5YmUgbWFueSwgd2UnbGwganVzdCB0YWtlIHRoZSAxc3Qgb25lXG4gICAgdmFyIGNvbnRlbnRUeXBlID0gY29udGVudFR5cGVLZXlzWzBdO1xuICAgIGlmIChoZWFkZXJzW2NvbnRlbnRUeXBlXS5tYXRjaCgvYXBwbGljYXRpb25cXC9qc29uL2kpKSB7XG4gICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgfSBlbHNlIGlmIChoZWFkZXJzW2NvbnRlbnRUeXBlXS5tYXRjaCgvYXBwbGljYXRpb25cXC94LXd3dy1mb3JtLXVybGVuY29kZWQvaSkpIHtcbiAgICAgIGJvZHkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkoYm9keSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGJvZHksIGhlYWRlcnMgfTtcbn07XG5cbi8qKlxuICogTWFrZXMgYW4gSFRUUCBSZXF1ZXN0LlxuICpcbiAqICoqQXZhaWxhYmxlIGluIENsb3VkIENvZGUgb25seS4qKlxuICpcbiAqIEJ5IGRlZmF1bHQsIFBhcnNlLkNsb3VkLmh0dHBSZXF1ZXN0IGRvZXMgbm90IGZvbGxvdyByZWRpcmVjdHMgY2F1c2VkIGJ5IEhUVFAgM3h4IHJlc3BvbnNlIGNvZGVzLiBZb3UgY2FuIHVzZSB0aGUgZm9sbG93UmVkaXJlY3RzIG9wdGlvbiBpbiB0aGUge0BsaW5rIFBhcnNlLkNsb3VkLkhUVFBPcHRpb25zfSBvYmplY3QgdG8gY2hhbmdlIHRoaXMgYmVoYXZpb3IuXG4gKlxuICogU2FtcGxlIHJlcXVlc3Q6XG4gKiBgYGBcbiAqIFBhcnNlLkNsb3VkLmh0dHBSZXF1ZXN0KHtcbiAqICAgdXJsOiAnaHR0cDovL3d3dy5wYXJzZS5jb20vJ1xuICogfSkudGhlbihmdW5jdGlvbihodHRwUmVzcG9uc2UpIHtcbiAqICAgLy8gc3VjY2Vzc1xuICogICBjb25zb2xlLmxvZyhodHRwUmVzcG9uc2UudGV4dCk7XG4gKiB9LGZ1bmN0aW9uKGh0dHBSZXNwb25zZSkge1xuICogICAvLyBlcnJvclxuICogICBjb25zb2xlLmVycm9yKCdSZXF1ZXN0IGZhaWxlZCB3aXRoIHJlc3BvbnNlIGNvZGUgJyArIGh0dHBSZXNwb25zZS5zdGF0dXMpO1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAbWV0aG9kIGh0dHBSZXF1ZXN0XG4gKiBAbmFtZSBQYXJzZS5DbG91ZC5odHRwUmVxdWVzdFxuICogQHBhcmFtIHtQYXJzZS5DbG91ZC5IVFRQT3B0aW9uc30gb3B0aW9ucyBUaGUgUGFyc2UuQ2xvdWQuSFRUUE9wdGlvbnMgb2JqZWN0IHRoYXQgbWFrZXMgdGhlIHJlcXVlc3QuXG4gKiBAcmV0dXJuIHtQcm9taXNlPFBhcnNlLkNsb3VkLkhUVFBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCBhIHtAbGluayBQYXJzZS5DbG91ZC5IVFRQUmVzcG9uc2V9IG9iamVjdCB3aGVuIHRoZSByZXF1ZXN0IGNvbXBsZXRlcy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBodHRwUmVxdWVzdChvcHRpb25zKSB7XG4gIGxldCB1cmw7XG4gIHRyeSB7XG4gICAgdXJsID0gcGFyc2Uob3B0aW9ucy51cmwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICB9XG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKG9wdGlvbnMsIGVuY29kZUJvZHkob3B0aW9ucykpO1xuICAvLyBzdXBwb3J0IHBhcmFtcyBvcHRpb25zXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5wYXJhbXMgPT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucy5xcyA9IG9wdGlvbnMucGFyYW1zO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLnBhcmFtcyA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zLnFzID0gcXVlcnlzdHJpbmcucGFyc2Uob3B0aW9ucy5wYXJhbXMpO1xuICB9XG4gIGNvbnN0IGNsaWVudCA9IGNsaWVudHNbdXJsLnByb3RvY29sXTtcbiAgaWYgKCFjbGllbnQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoYFVuc3VwcG9ydGVkIHByb3RvY29sICR7dXJsLnByb3RvY29sfWApO1xuICB9XG4gIGNvbnN0IHJlcXVlc3RPcHRpb25zID0ge1xuICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgcG9ydDogTnVtYmVyKHVybC5wb3J0KSxcbiAgICBwYXRoOiB1cmwucGF0aG5hbWUsXG4gICAgaG9zdG5hbWU6IHVybC5ob3N0bmFtZSxcbiAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnMsXG4gICAgZW5jb2Rpbmc6IG51bGwsXG4gICAgZm9sbG93UmVkaXJlY3RzOiBvcHRpb25zLmZvbGxvd1JlZGlyZWN0cyA9PT0gdHJ1ZSxcbiAgfTtcbiAgaWYgKHJlcXVlc3RPcHRpb25zLmhlYWRlcnMpIHtcbiAgICBPYmplY3Qua2V5cyhyZXF1ZXN0T3B0aW9ucy5oZWFkZXJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHJlcXVlc3RPcHRpb25zLmhlYWRlcnNba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZGVsZXRlIHJlcXVlc3RPcHRpb25zLmhlYWRlcnNba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpZiAodXJsLnNlYXJjaCkge1xuICAgIG9wdGlvbnMucXMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLnFzLCBxdWVyeXN0cmluZy5wYXJzZSh1cmwucXVlcnkpKTtcbiAgfVxuICBpZiAodXJsLmF1dGgpIHtcbiAgICByZXF1ZXN0T3B0aW9ucy5hdXRoID0gdXJsLmF1dGg7XG4gIH1cbiAgaWYgKG9wdGlvbnMucXMpIHtcbiAgICByZXF1ZXN0T3B0aW9ucy5wYXRoICs9IGA/JHtxdWVyeXN0cmluZy5zdHJpbmdpZnkob3B0aW9ucy5xcyl9YDtcbiAgfVxuICBpZiAob3B0aW9ucy5hZ2VudCkge1xuICAgIHJlcXVlc3RPcHRpb25zLmFnZW50ID0gb3B0aW9ucy5hZ2VudDtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlcSA9IGNsaWVudC5yZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCBtYWtlQ2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0LCBvcHRpb25zKSk7XG4gICAgaWYgKG9wdGlvbnMuYm9keSkge1xuICAgICAgcmVxLndyaXRlKG9wdGlvbnMuYm9keSk7XG4gICAgfVxuICAgIHJlcS5vbignZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgIH0pO1xuICAgIHJlcS5lbmQoKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIFBhcnNlLkNsb3VkLkhUVFBPcHRpb25zXG4gKiBAcHJvcGVydHkge1N0cmluZ3xPYmplY3R9IGJvZHkgVGhlIGJvZHkgb2YgdGhlIHJlcXVlc3QuIElmIGl0IGlzIGEgSlNPTiBvYmplY3QsIHRoZW4gdGhlIENvbnRlbnQtVHlwZSBzZXQgaW4gdGhlIGhlYWRlcnMgbXVzdCBiZSBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQgb3IgYXBwbGljYXRpb24vanNvbi4gWW91IGNhbiBhbHNvIHNldCB0aGlzIHRvIGEge0BsaW5rIEJ1ZmZlcn0gb2JqZWN0IHRvIHNlbmQgcmF3IGJ5dGVzLiBJZiB5b3UgdXNlIGEgQnVmZmVyLCB5b3Ugc2hvdWxkIGFsc28gc2V0IHRoZSBDb250ZW50LVR5cGUgaGVhZGVyIGV4cGxpY2l0bHkgdG8gZGVzY3JpYmUgd2hhdCB0aGVzZSBieXRlcyByZXByZXNlbnQuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBlcnJvciBUaGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgcmVxdWVzdCBmYWlscy4gSXQgd2lsbCBiZSBwYXNzZWQgYSBQYXJzZS5DbG91ZC5IVFRQUmVzcG9uc2Ugb2JqZWN0LlxuICogQHByb3BlcnR5IHtCb29sZWFufSBmb2xsb3dSZWRpcmVjdHMgV2hldGhlciB0byBmb2xsb3cgcmVkaXJlY3RzIGNhdXNlZCBieSBIVFRQIDN4eCByZXNwb25zZXMuIERlZmF1bHRzIHRvIGZhbHNlLlxuICogQHByb3BlcnR5IHtPYmplY3R9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0LlxuICogQHByb3BlcnR5IHtTdHJpbmd9IG1ldGhvZCBUaGUgbWV0aG9kIG9mIHRoZSByZXF1ZXN0LiBHRVQsIFBPU1QsIFBVVCwgREVMRVRFLCBIRUFELCBhbmQgT1BUSU9OUyBhcmUgc3VwcG9ydGVkLiBXaWxsIGRlZmF1bHQgdG8gR0VUIGlmIG5vdCBzcGVjaWZpZWQuXG4gKiBAcHJvcGVydHkge1N0cmluZ3xPYmplY3R9IHBhcmFtcyBUaGUgcXVlcnkgcG9ydGlvbiBvZiB0aGUgdXJsLiBZb3UgY2FuIHBhc3MgYSBKU09OIG9iamVjdCBvZiBrZXkgdmFsdWUgcGFpcnMgbGlrZSBwYXJhbXM6IHtxIDogJ1NlYW4gUGxvdHQnfSBvciBhIHJhdyBzdHJpbmcgbGlrZSBwYXJhbXM6cT1TZWFuIFBsb3R0LlxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gc3VjY2VzcyBUaGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgcmVxdWVzdCBzdWNjZXNzZnVsbHkgY29tcGxldGVzLiBJdCB3aWxsIGJlIHBhc3NlZCBhIFBhcnNlLkNsb3VkLkhUVFBSZXNwb25zZSBvYmplY3QuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdXJsIFRoZSB1cmwgdG8gc2VuZCB0aGUgcmVxdWVzdCB0by5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cy5lbmNvZGVCb2R5ID0gZW5jb2RlQm9keTtcbiJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFBQSxhQUFBLEdBQUFDLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBQyxZQUFBLEdBQUFGLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBRSxPQUFBLEdBQUFILHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBRyxnQkFBQSxHQUFBSCxPQUFBO0FBQ0EsSUFBQUksSUFBQSxHQUFBSixPQUFBO0FBQTRCLFNBQUFELHVCQUFBTSxHQUFBLFdBQUFBLEdBQUEsSUFBQUEsR0FBQSxDQUFBQyxVQUFBLEdBQUFELEdBQUEsS0FBQUUsT0FBQSxFQUFBRixHQUFBO0FBRTVCLE1BQU1HLE9BQU8sR0FBRztFQUNkLE9BQU8sRUFBRUMscUJBQUk7RUFDYixRQUFRLEVBQUVDO0FBQ1osQ0FBQztBQUVELFNBQVNDLFlBQVlBLENBQUNDLE9BQU8sRUFBRUMsTUFBTSxFQUFFO0VBQ3JDLE9BQU8sVUFBVUMsUUFBUSxFQUFFO0lBQ3pCLE1BQU1DLE1BQU0sR0FBRyxFQUFFO0lBQ2pCRCxRQUFRLENBQUNFLEVBQUUsQ0FBQyxNQUFN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